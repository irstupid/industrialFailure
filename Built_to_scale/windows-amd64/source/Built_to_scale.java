/* autogenerated by Processing revision 1293 on 2024-08-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Built_to_scale extends PApplet {



Player player;
PImage background;
PImage[] enemyTypes;
ArrayList<Enemy> enemys;
ArrayList<Carrot> carrots;
PImage heart;
PImage carrot;
PImage puff;
Flower flower;
ArrayList<Explosion> explosions;
int spawnTime;
int difficulty;
int gameState = 2;
PImage instructions;
PImage title;

SoundFile pew;
SoundFile boom;
SoundFile dash;
SoundFile hurt;
SoundFile lose;
SoundFile ponk;
SoundFile poof;
SoundFile music;

public void setup()
{
  /* size commented out by preprocessor */;
  rectMode(CENTER);
  enemyTypes = new PImage[6];
  enemyTypes[0] = loadImage("red.png");
  enemyTypes[1] = loadImage("orange.png");
  enemyTypes[2] = loadImage("yellow.png");
  enemyTypes[3] = loadImage("green.png");
  enemyTypes[4] = loadImage("blue.png");
  enemyTypes[5] = loadImage("purple.png");
  background = loadImage("grass.png");
  heart = loadImage("heart.png");
  heart.resize(400, 400);
  carrot = loadImage("carrot.png");
  puff = loadImage("puff.png");
  puff.resize(200, 200);
  instructions = loadImage("instructions.png");
  title = loadImage("title.png");
  
  pew = new SoundFile(this, "pew");
  boom = new SoundFile(this, "boom");
  dash = new SoundFile(this, "dash");
  hurt = new SoundFile(this, "hurt");
  lose = new SoundFile(this, "lose");
  lose.amp(10);
  ponk = new SoundFile(this, "ponk");
  poof = new SoundFile(this, "poof");
  music = new SoundFile(this, "garden banger.wav");
  
  player = new Player(width/2, height/2);
  enemys = new ArrayList<Enemy>();
  //enemys.add(new Enemy(width, height, 4));
  carrots = new ArrayList<Carrot>();
  flower = new Flower();
  explosions = new ArrayList<Explosion>();
  difficulty = 240;
  spawnTime = 0;
}

public void draw()
{
  if(!music.isPlaying())
  {
    music.play();
  }
  
  if(gameState == 0)
  {
    spawnTime--;
    if(spawnTime <= 0)
    {
      enemySpawn();
      difficulty = round(difficulty/1.05f);
      spawnTime = difficulty;
    }
  }
  push();
    tint(0xFFFFFFFF, 100);
    image(background, 0, 0);
  pop();
  if(gameState == 0 || gameState == 1)
  {
    flower.draw();
    player.draw();
    for(int i = 0; i < enemys.size(); i++)
    {
      enemys.get(i).draw();
    }
    for(int i = 0; i < carrots.size(); i++)
    {
      carrots.get(i).draw();
    }
    for(int i = 0; i < explosions.size(); i++)
    {
      explosions.get(i).draw();
    }
    if(player.health > 0){image(heart, 410, -10);}
    if(player.health > 1){image(heart, 350, -10);}
    if(player.health > 2){image(heart, 290, -10);}
  }
  else if(gameState == 2)
  {
    image(title, 0, 0);
  }
  else
  {
    image(instructions, 0, 0);
  }
}

public void enemySpawn()
{
  if(random(0, 2) > 1)
  {
    if(random(0, 2) > 1)
    {
      enemys.add(new Enemy(-250, random(0, width), floor(random(0, 6))));
    }
    else
    {
      enemys.add(new Enemy(width + 250, random(0, width), floor(random(0, 6))));
    }
  }
  else
  {
    if(random(0, 2) > 1)
    {
      enemys.add(new Enemy(random(0, width), -250, floor(random(0, 6))));
    }
    else
    {
      enemys.add(new Enemy(random(0, width), width + 250, floor(random(0, 6))));
    }
  }
}

public void keyPressed()
{
  if(gameState == 0)
  {
    player.keyPressed(); 
    flower.keyPressed();
  }
  else if((gameState == 2 || gameState == 3) && key == 'z')
  {
    gameState = 0;
    player = new Player(width/2, height/2);
    enemys = new ArrayList<Enemy>();
    //enemys.add(new Enemy(width, height, 4));
    carrots = new ArrayList<Carrot>();
    flower = new Flower();
    explosions = new ArrayList<Explosion>();
    difficulty = 240;
    spawnTime = difficulty;
  }
  else if(gameState == 2 && key == 'i')
  {
    gameState = 3;
  }
}
public void keyReleased()
{
  if(gameState == 0)
  {
    player.keyReleased();
  }
}
class Carrot
{
  float x;
  float y;
  float r;
  PImage me;
  int unHit = 20;
  
  Carrot(float x, float y, float r)
  {
    this.x = x;
    this.y = y;
    this.r = r;
    me = carrot;
  }
  
  public void draw()
  {
    if(gameState == 0)
    {
      unHit--;
      x += cos(r) * 5;
      y += sin(r) * 5;
      push();
          translate(x, y);
          rotate(r + radians(90));
          translate(-408, -365);
          image(carrot, 0, 0);
      pop();
      //circle(x, y, 30);
    }
  }
  
  public void die()
  {
    carrots.remove(this);
  }
}
class Enemy
{
  float x;
  float y;
  float Rx;
  float Ry;
  int type;
  float speed;
  float scale = 1;
  int health = 5;
  int shrinkTime;
  
  PImage me;
  
  float SPEED;
  
  Enemy(float x, float y, int type)
  {
    this.Rx = x;
    this.Ry = y;
    this.type = type;
    
    me = enemyTypes[type];
  }
  
  public void draw()
  {
    if(gameState == 0)
    {
      Rx += constrain(-cos(atan2(y - player.x, x - player.x)), -1, 1) * 0.8f;
      Ry += constrain(-sin(atan2(y - player.y, x - player.y)), -1, 1) * 0.8f;
      shrinkTime--;
      
      for(int i = 0; i < carrots.size(); i++)
      {
        if(distance(carrots.get(i).x, carrots.get(i).y) < 15)
        {
          if(scale < 1)
          {
            health--;
          }
          carrots.get(i).die();
          boom.play();
        }
      }
      for(int i = 0; i < explosions.size(); i++)
      {
        if(distance(explosions.get(i).x, explosions.get(i).y) < 100)
        {
          shrinkTime = 300;
        }
      }
      
      if(shrinkTime > 0 && scale > 0.5f)
      {
        scale -= 0.05f;
      }
      else if(shrinkTime <= 0 && scale < 1)
      {
        scale += 0.05f;
      }
      
      x = Rx;
      y = Ry;
      x += 800 * abs(1 - scale);
      y += 800 * abs(1 - scale);
      if(health <= 0)
      {
        enemys.remove(this);
      }
    }
    
    push();
      scale(scale);
      switch(type)
      {
        case 0:
          translate(-75, -105);
          break;
        case 1:
          translate(25, 0);
          break;
        case 2:
          translate(-40, -216);
          break;
        case 3:
          translate(-50, -102);
          break;
        case 4:
          translate(53, -107);
          break;
        case 5:
          translate(0, -30 * scale);
          break;
      }
      image(me, x - me.width/2, y - me.height/2);
    pop();
  }
  
  public float distance(float pX, float pY)
  {
    switch(type)
      {
        case 0:
          return min(boxDistance(pX, pY, x * scale, y * scale - 65 * scale, 100 * scale, 230 * scale), boxDistance(pX, pY, x * scale - 110 * scale, y * scale - 65 * scale + 125 * scale, 100 * scale, 230 * scale));
        case 1:
          return boxDistance(pX, pY, x * scale, y * scale, 200 * scale, 200 * scale);
        case 2:
          return min(boxDistance(pX, pY, x * scale, y * scale, 300 * scale, 100 * scale), boxDistance(pX, pY, x * scale + 110 * scale, y * scale - 110 * scale, 100 * scale, 100 * scale));
        case 3:
          return min(boxDistance(pX, pY, x * scale - 5 * scale, y * scale, 300 * scale, 100 * scale), boxDistance(pX, pY, x * scale - 110 * scale, y * scale - 110 * scale, 100 * scale, 100 * scale));
        case 4:
          //rect(x * scale, y * scale - 65 * scale, 100 * scale, 230 * scale);
          //rect(x * scale + 110 * scale, y * scale - 65 * scale + 110 * scale, 100 * scale, 200 * scale);
          return min(boxDistance(pX, pY, x * scale, y * scale - 65 * scale, 100 * scale, 230 * scale), boxDistance(pX, pY, x * scale + 110 * scale, y * scale - 65 * scale + 110 * scale, 100 * scale, 200 * scale));
        case 5:
          return boxDistance(pX, pY, x * scale, y * scale, 420 * scale, 100 * scale);
        default:
          return 1000f;
      }
  }
  
  public PVector closePoint(float pX, float pY)
  {
    switch(type)
      {
        case 0:
          if(dist(x * scale, y * scale - 65 * scale, pX, pY) < dist(x * scale - 110 * scale, y * scale - 65 * scale + 125 * scale, pX, pY))
          {
            return new PVector(x * scale, y * scale - 65 * scale);
          }
          else
          {
            return new PVector(x * scale - 110 * scale, y * scale - 65 * scale + 125 * scale);
          }
        case 1:
          return new PVector(x * scale, y * scale);
        case 2:
          if(dist(x * scale, y * scale, pX, pY) < dist(x * scale + 110 * scale, y * scale - 110 * scale, pX, pY))
          {
            return new PVector(x * scale, y * scale);
          }
          else
          {
            return new PVector(x * scale + 110 * scale, y * scale - 110 * scale);
          }
        case 3:
          if(dist(x * scale - 5 * scale, y * scale, pX, pY) < dist(x * scale - 110 * scale, y * scale - 110 * scale, pX, pY))
          {
            return new PVector(x * scale - 5 * scale, y * scale);
          }
          else
          {
            return new PVector(x * scale - 110 * scale, y * scale - 110 * scale);
          }
        case 4:
          if(dist(x * scale, y * scale - 65 * scale, pX, pY) < dist(x * scale + 110 * scale, y * scale - 65 * scale + 110 * scale, pX, pY))
          {
            return new PVector(x * scale, y * scale - 65 * scale);
          }
          else
          {
            return new PVector(x * scale + 110 * scale, y * scale - 65 * scale + 110 * scale);
          }
        case 5:
        return new PVector(x * scale, y * scale);
        default:
          return new PVector(0, 0);
      }
  }
  
  public float boxDistance(float pX, float pY, float bX, float bY, float w, float h)
  {
    pX = pX - bX;
    pY = pY - bY;
    return sqrt(sq(max(abs(pX) - w/2, 0)) + sq(max(abs(pY) - h/2, 0)));
  }
}
class Explosion
{
  float x;
  float y;
  float[] puffM;
  float[] puffV;
  float[] puffD;
  float[] puffR;
  float[] puffRV;
  PImage me;
  float scale = 1;
  
  int PUFFS = 30;
  
  Explosion(float x, float y)
  {
    me = puff;
    this.x = x;
    this.y = y;
    puffM = new float[PUFFS];
    puffV = new float[PUFFS];
    puffD = new float[PUFFS];
    puffR = new float[PUFFS];
    puffRV = new float[PUFFS];
    for(int i = 0; i < PUFFS; i++)
    {
      puffV[i] = random(1, 9);
      puffD[i] = random(0, TAU);
      puffRV[i] = random(-0.5f, 0.5f);
    }
  }
  
  public void draw()
  {
    scale -= 0.01f * 1.2f/scale;
    if(scale < 0.1f)
    {
      explosions.remove(this);
      me.resize(200, 200);
    }
    push();
      scale(scale);
      for(int i = 0; i < PUFFS; i++)
      {
        puffM[i] += puffV[i];
        puffV[i] = puffV[i]/1.1f;
        puffR[i] += puffRV[i];
        push();
            translate(x/scale, y/scale);
            translate(cos(puffD[i]) * puffM[i], sin(puffD[i]) * puffM[i]);
            rotate(puffR[i]);
            translate(-53 * scale, -143 * scale);
            image(me, 0, 0);
        pop();
      }
    pop();
  }
}
class Flower
{
  float x;
  float y;
  PImage me;
  int state;
  
  Flower()
  {
    me = loadImage("flower.png");
    me.resize(400, 400);
  }
  
  public void draw()
  {
    if(state == 1)
    {
      for(int i = 0; i < carrots.size(); i++)
      {
        if(dist(carrots.get(i).x, carrots.get(i).y, x, y) < 40)
        {
          state = 0;
        }
      }
      
      push();
        fill(0xFFFF0000, 100);
        circle(x, y, 200);
      pop();
      push();
        translate(x, y);
        rotate(0);
        translate(-210, -184);
        image(me, 0, 0);
      pop();
    }
  }
  
  public void keyPressed()
  {
    if(key == 'o')
    {
      if(state == 1)
      {
        state = 0;
        explosions.add(new Explosion(x, y));
        poof.play();
      }
      else
      {
        x = player.x;
        y = player.y;
        ponk.play();
        state = 1;
      }
    }
  }
}
class Player
{
  float x;
  float y;
  float xV;
  float yV;
  int state = 1;
  int cycle;
  float speed = 2;
  int coolDown;
  int iv;
  int flash;
  int health = 3;
  float kbx;
  float kby;
  float direction;
  int strong;
  
  PImage idle;
  PImage walk1;
  PImage walk2;
  PImage roll;
  
  float SPEED = 2;
  
  Player(float x, float y)
  {
    this.x = x;
    this.y = y;
    
    idle = loadImage("idle.png");
    walk1 = loadImage("walk1.png");
    walk2 = loadImage("walk2.png");
    roll = loadImage("roll.png");
    idle.resize(400, 400);
    walk1.resize(400, 400);
    walk2.resize(400, 400);
    roll.resize(400, 400);
  }
  
  public void draw()
  {
    if(gameState == 0)
    {
      strong--;
      x += xV * speed + kbx;
      y += yV * speed + kby;
      x = constrain(x, 25, width - 25);
      y = constrain(y, 25, height - 25);
      kbx = kbx/1.3f;
      kby = kby/1.3f;
      coolDown--;
      iv--;
      flash++;
      if(flash > 20)
      {
        flash = 0;
      }
      if(state != 2)
      {
        if(xV != 0 || yV != 0)
        {
          direction = atan2(yV, xV);
          state = 1;
        }
        else
        {
          state = 0;
        }
        cycle++;
        if(cycle > 30)
        {
          cycle = 0;
        }
        speed = SPEED;
        
        collisonDetection();
      }
      else
      {
        cycle--;
        speed = SPEED * 3;
        if(cycle <= 0)
        {
          state = 0;
        }
      }
      speed = speed * (strong > 0 ? 3 : 1);
    }
    else
    {
      state = 0;
      cycle--;
      if(round(400 * cycle/60) < 1)
      {
        gameState = 2;
        return;
      }
      idle.resize(round(400 * cycle/60), round(400 * cycle/60));
    }
    
    push();
    if(flash < 10 && iv > 0 && gameState == 0)
    {
      tint(0xFFFF0000);
    }
    else if(strong > 0)
    {
      tint(0xFFFF8800);
    }
    if(state == 0)
    {
      image(idle, x - idle.width/2, y - idle.height/2 + 17);
    }
    else if(state == 1)
    {
      if(cycle < 10)
      {
        image(walk1, x - walk1.width/2, y - walk1.height/2 + 17);
      }
      else if(cycle < 15)
      {
        image(idle, x - idle.width/2, y - idle.height/2 + 17);
      }
      else if(cycle < 25)
      {
        image(walk2, x - walk2.width/2, y - walk2.height/2 + 17);
      }
      else
      {
        image(idle, x - idle.width/2, y - idle.height/2 + 17);
      }
    }
    else if(state == 2) 
    {
      push();
        translate(x, y);
        rotate(-cycle/3f);
        translate(-200, -176);
        image(roll, 0, 0);
      pop();
    }
    pop();
    
    fill(0xFFFFFFFF, 100);
    //ellipse(x, y, 50, 50);
    
    if(health <= 0 && gameState == 0)
    {
      lose.play();
      cycle = 60;
      gameState = 1;
    }
  }
  
  public void keyPressed()
  {
    switch(key)
    {
      case 'w':
        yV += -1;
        break;
      case 'a':
        xV += -1;
        break;
      case 's':
        yV += 1;
        break;
      case 'd':
        xV += 1;
        break;
      case ' ':
        if(coolDown <= 0)
        {
          dash.play();
          state = 2;
          cycle = 30;
          coolDown = 90;
        }
        break;
      case 'i':
        if(state != 2)
        {
          pew.play();
          carrots.add(new Carrot(x, y, direction));
        }
        break;
    }
  }
  
  public void keyReleased()
  {
    switch(key)
    {
      case 'w':
        yV += 1;
        break;
      case 'a':
        xV += 1;
        break;
      case 's':
        yV += -1;
        break;
      case 'd':
        xV += -1;
        break;
    }
  }
  
  public void collisonDetection()
  {
    for(int i = 0; i < enemys.size(); i++)
    {
      if(enemys.get(i).distance(x, y) < 25)
      {
        if(iv < 0)
        {
          health--;
          iv = 60;
        }
        PVector pushPoint = enemys.get(i).closePoint(x, y);
        pushPoint = new PVector(x, y).sub(pushPoint);
        pushPoint.normalize();
        kbx = pushPoint.x * 30;
        kby = pushPoint.y * 30;
        hurt.play();
      }
    }
    if(iv < 0)
    {
      for(int i = 0; i < explosions.size(); i++)
      {
        if(dist(explosions.get(i).x, explosions.get(i).y, x, y) < 125)
        {
          health--;
          iv = 60;
          hurt.play();
        }
      }
    }
    for(int i = 0; i < carrots.size(); i++)
    {
      if(dist(carrots.get(i).x, carrots.get(i).y, x, y) < 40 && carrots.get(i).unHit < 0)
      {
        carrots.get(i).die();
        strong = 120;
      }
    }
  }
}


  public void settings() { size(800, 800, P2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Built_to_scale" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
